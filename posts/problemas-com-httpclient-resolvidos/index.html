<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Solucionando problemas de sincronismo de requisições em paralelo com SemaphoreSlim | Jojo's Exception</title><meta name=keywords content="dotnet,parallel,async"><meta name=description content="Dando um push() no problema Um dos desafios que nem com as técnicas mais sombrias de debugging me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos estavam retornando uma exceção baseada no cancelamento das referências das instâncias dos vários CancellationToken utilizados para construir o cliente das requisições.
Foi uma discussão bem legal com alguns monstros da CLR e até mesmo do Roslyn, que com uma paciência de Jó, conseguiram ir a fundo na explicação sobre o funcionamento da pilha de rede dentro do ."><meta name=author content="Jojo"><link rel=canonical href=https://exception.blog/posts/problemas-com-httpclient-resolvidos/><link href=https://exception.blog/assets/css/stylesheet.min.19d8234f7520f2216aca845b9f292982671403accc7e754ceb099b228a5980fe.css integrity="sha256-GdgjT3Ug8iFqyoRbnykpgmcUA6zMfnVM6wmbIopZgP4=" rel="preload stylesheet" as=style><link rel=icon href=https://exception.blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://exception.blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://exception.blog/favicon-32x32.png><link rel=apple-touch-icon href=https://exception.blog/apple-touch-icon.png><link rel=mask-icon href=https://exception.blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><meta property="og:title" content="Solucionando problemas de sincronismo de requisições em paralelo com SemaphoreSlim"><meta property="og:description" content="Dando um push() no problema Um dos desafios que nem com as técnicas mais sombrias de debugging me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos estavam retornando uma exceção baseada no cancelamento das referências das instâncias dos vários CancellationToken utilizados para construir o cliente das requisições.
Foi uma discussão bem legal com alguns monstros da CLR e até mesmo do Roslyn, que com uma paciência de Jó, conseguiram ir a fundo na explicação sobre o funcionamento da pilha de rede dentro do ."><meta property="og:type" content="article"><meta property="og:url" content="https://exception.blog/posts/problemas-com-httpclient-resolvidos/"><meta property="article:published_time" content="2020-12-30T18:21:14-03:00"><meta property="article:modified_time" content="2020-12-30T18:21:14-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solucionando problemas de sincronismo de requisições em paralelo com SemaphoreSlim"><meta name=twitter:description content="Dando um push() no problema Um dos desafios que nem com as técnicas mais sombrias de debugging me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos estavam retornando uma exceção baseada no cancelamento das referências das instâncias dos vários CancellationToken utilizados para construir o cliente das requisições.
Foi uma discussão bem legal com alguns monstros da CLR e até mesmo do Roslyn, que com uma paciência de Jó, conseguiram ir a fundo na explicação sobre o funcionamento da pilha de rede dentro do ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solucionando problemas de sincronismo de requisições em paralelo com SemaphoreSlim","name":"Solucionando problemas de sincronismo de requisições em paralelo com SemaphoreSlim","description":"Dando um push() no problema Um dos desafios que nem com as técnicas mais sombrias de debugging me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos …","keywords":["dotnet","parallel","async"],"articleBody":"Dando um push() no problema Um dos desafios que nem com as técnicas mais sombrias de debugging me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos estavam retornando uma exceção baseada no cancelamento das referências das instâncias dos vários CancellationToken utilizados para construir o cliente das requisições.\nFoi uma discussão bem legal com alguns monstros da CLR e até mesmo do Roslyn, que com uma paciência de Jó, conseguiram ir a fundo na explicação sobre o funcionamento da pilha de rede dentro do .NET, e também, sobre a abstração que estava consumindo. No geral, as diversas tasks que havia emitido, que foram passadas para serem aguardadas sua execução até o fim como parâmetro da função WhenAll lá do binário System.Runtime.dll.\n Para não descer muito o nível, e deixar tudo de maneira bem entendível, não vou abranger muito a explicação que absorvi, e focar na resolução desse problema relativamente simples.\n Nem sempre é tudo uma questão de alto nível Em contextos de paralelismo com tarefas que consomem muito tempo do processador, ainda que existem outras várias camadas para orquestrarem essas tarefas, desde de o próprio CPU até o sistema operacional e a própria stack de desenvolvimento, cabe a nós implementarmos controles eficazes na orquestração nas nossas próprias tarefas.\nEspecialmente nas linguagens de altíssimo nível, que entregam uma abstração muito abstrata - eu ri por dentro aqui - do que realmente é uma thread, devemos ter essa atenção dobrada para não cair em um contexto de cancelamento pois o tempo de resposta da aplicação para o ambiente onde foi delegada sua execução chegar ao limite.\nNesse cenário do HttpClientHandler e do HttpClient isso fica mais fácil de se perceber, mesmo que você implemente um timeout na casa dos TimeSpam.FromDays(666), se o tempo de execução de qualquer uma das funções assíncronas do HttpClient, como a mais utilizada HttpClient.SendAsync(HttpRequestMessage), podem retornar um timeout, mas não da resposta HTTP do servidor, e sim da sua Task que está no limbo do atual contexto de processamento.\n Vai por mim, evite utilizar funções que podem receber uma sobrecarga de uma instância de CancellationToken, se ela pode trabalhar com os status provenientes dessa estrutura, algum motivo tem.\n Para simplificar o entendimento de todo esse cenário intangível, vamos trazer ao código uma péssima prática de programação (que quase me fez desistir do desenvolvimento do HttpDoom) relacionada ao paralelismo e assincronicidade de código:\nusing System; using System.Linq; using System.Net.Http; using System.Threading.Tasks; namespace Exception.Examples { internal static class Program { public static async Task Main() { var tasks = await Task.WhenAll(Enumerable.Range(1, 5000) .Select(_ = new HttpClient().GetAsync(\"https://google.com\"))); tasks .Where(t = true) .ToList() .ForEach(r = Console.WriteLine($\"Google answered {r.StatusCode}\")); } } }  Nota: Top-level programs ainda tem algumas coisas bem peculiares para tratar inferência dinâmica de tipos e de contextos assíncronos e paralelos no C# 9, então vamos no clássico entrypoint program mesmo.\n Um código bem simples, e que - se liga no plot twist - funciona perfeitamente bem! O motivo de tudo funcionar como deveria, é que temos implementado somente uma única responsabilidade dentro da função paralela e assíncrona, onde é iniciado 5000 Task que será aguardada logo no seu enclosure que é justamente a própria Task.WhenAll, por ser uma expressão LINQ, o código pode ser um pouco difícil de ler, mas nada que alguns minutos de leitura não resolva.\nO problema que estamos tentando criar, acontece quando além dessa única coisa que é feita (return new HttpClient().GetAsync(\"https://google.com\")), na expressão anônima da extensão Select() lá do LINQ), adicionamos alguma função que freia a execução dessa thread, por exemplo, escrever na tela informações da requisição conforme são executadas, vamos alterar um pouco o código e adicionar algumas funções que fação operações de IO:\n// ... await Task.WhenAll(Enumerable.Range(1, 5000) .Select(async _ = { try { var response = await new HttpClient().GetAsync(\"https://google.com\"); Console.Write($\"Remote {response.RequestMessage?.RequestUri} answered {response.StatusCode}, \"); var content = await response.Content.ReadAsByteArrayAsync(); Console.WriteLine($\"with a length of {content.Length} byte(s)\"); return response; } catch (System.Exception e) { Console.WriteLine(e.InnerException != null ? $\"Error: {e.InnerException.Message}\" : $\"Error: {e.Message}\"); } })); // ... Nesse cenário como temos a interação com operações que causam problemas na hora de serem executadas, e nem por realizarem operações de IO com response.Content.ReadAsByteArrayAsync() mas sim pela escrita na tela usando System.Console, que causa um lock e vira uma bagunça, quem estiver disponível, executa essa função.\nQuando você executar esse código (além de receber um belíssimo banimento da Google por realizar milhares de requisições em tão pouco tempo), vai se deparar com algumas exceções de Task ao invés das instâncias de classes referentes a pilha de rede do .NET, no caso a famosa mensagem “The operation was canceled”.\nE justamente quando receber essa resposta, é que os problemas do paralelismo começam a perturbar sua sanidade.\nResolvendo com uma boa sinalização Existem diversas APIs que são fornecidas dentro do CLR para sanar os problemas de paralelismo que correspondem a estes erros, podemos realizar a implementação mais simples que conheço, que tem pouquíssimas alterações no código fonte original da aplicação, utilizando SemaphoreSlim para corrigir esse fiasco.\nPodemos resumir esse elemento de System.Threads como sendo uma entidade responsável por limitar o número de threads que podem acessar uma pool de recursos, que é justamente o que causa “The operation was canceled” dentro de uma Task. Sua implementação é bem simples, e ele receber por padrão um único argumento correspondente a quantidade máxima de threads que podem ser alocadas para acessar estes recursos:\nvar semaphore = new SemaphoreSlim(Environment.ProcessorCount); await Task.WhenAll(Enumerable.Range(1, 1000) .Select(async _ = { await semaphore.WaitAsync(); try { var response = await new HttpClient().GetAsync(\"https://zup.com.br\"); Console.Write($\"Remote {response.RequestMessage?.RequestUri} answered {response.StatusCode}, \"); var content = await response.Content.ReadAsByteArrayAsync(); Console.WriteLine($\"with a length of {content.Length} byte(s)\"); return response; } catch (System.Exception e) { Console.WriteLine(e.InnerException != null ? $\"Error: {e.InnerException.Message}\" : $\"Error: {e.Message}\"); return null; } finally { semaphore.Release(); } })); Agora além de podermos controlar o número de threads que serão utilizados para realizar as requisições, também não vamos ter problemas de concorrência ao tentar processar essa pool de tarefas alocadas no fluxo de execução da aplicação.\n","wordCount":"996","inLanguage":"en","datePublished":"2020-12-30T18:21:14-03:00","dateModified":"2020-12-30T18:21:14-03:00","author":{"@type":"Person","name":"Jojo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://exception.blog/posts/problemas-com-httpclient-resolvidos/"},"publisher":{"@type":"Organization","name":"Jojo's Exception","logo":{"@type":"ImageObject","url":"https://exception.blog/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://exception.blog accesskey=h title="Jojo's Exception (Alt + H)">Jojo's Exception</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://exception.blog/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Solucionando problemas de sincronismo de requisições em paralelo com SemaphoreSlim</h1><div class=post-description></div><div class=post-meta>December 30, 2020&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Jojo</div></header><div class=post-content><h1 id=dando-um-push-no-problema>Dando um <code>push()</code> no problema<a hidden class=anchor aria-hidden=true href=#dando-um-push-no-problema>#</a></h1><p>Um dos desafios que nem com as técnicas mais sombrias de <em>debugging</em> me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos estavam retornando uma exceção baseada no cancelamento das referências das instâncias dos vários <code>CancellationToken</code> utilizados para construir o cliente das requisições.</p><p>Foi uma discussão bem legal com alguns monstros da CLR e até mesmo do Roslyn, que com uma paciência de Jó, conseguiram ir a fundo na explicação sobre o funcionamento da pilha de rede dentro do .NET, e também, sobre a abstração que estava consumindo. No geral, as diversas <em>tasks</em> que havia emitido, que foram passadas para serem aguardadas sua execução até o fim como parâmetro da função <code>WhenAll</code> lá do binário <code>System.Runtime.dll</code>.</p><blockquote><p>Para não descer muito o nível, e deixar tudo de maneira bem entendível, não vou abranger muito a explicação que absorvi, e focar na resolução desse problema relativamente simples.</p></blockquote><h1 id=nem-sempre-é-tudo-uma-questão-de-alto-nível>Nem sempre é tudo uma questão de alto nível<a hidden class=anchor aria-hidden=true href=#nem-sempre-é-tudo-uma-questão-de-alto-nível>#</a></h1><p>Em contextos de paralelismo com tarefas que consomem muito tempo do processador, ainda que existem outras várias camadas para orquestrarem essas tarefas, desde de o próprio CPU até o sistema operacional e a própria <em>stack</em> de desenvolvimento, cabe a nós implementarmos controles eficazes na orquestração nas nossas próprias tarefas.</p><p>Especialmente nas linguagens de altíssimo nível, que entregam uma abstração <em>muito abstrata - eu ri por dentro aqui -</em> do que realmente é uma <em>thread</em>, devemos ter essa atenção dobrada para não cair em um contexto de cancelamento pois o tempo de resposta da aplicação para o ambiente onde foi delegada sua execução chegar ao limite.</p><p>Nesse cenário do <code>HttpClientHandler</code> e do <code>HttpClient</code> isso fica mais fácil de se perceber, mesmo que você implemente um <em>timeout</em> na casa dos <code>TimeSpam.FromDays(666)</code>, se o tempo de execução de qualquer uma das funções assíncronas do <code>HttpClient</code>, como a mais utilizada <code>HttpClient.SendAsync(HttpRequestMessage)</code>, podem retornar um <em>timeout</em>, mas não da resposta HTTP do servidor, e sim da sua <code>Task</code> que está no limbo do atual contexto de processamento.</p><blockquote><p>Vai por mim, evite utilizar funções que podem receber uma sobrecarga de uma instância de <code>CancellationToken</code>, se ela pode trabalhar com os <em>status</em> provenientes dessa estrutura, algum motivo tem.</p></blockquote><p>Para simplificar o entendimento de todo esse cenário intangível, vamos trazer ao código uma péssima prática de programação (que quase me fez desistir do desenvolvimento do <a href=https://github.com/BizarreNULL/httpdoom/>HttpDoom</a>) relacionada ao paralelismo e assincronicidade de código:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.Linq;
<span style=color:#66d9ef>using</span> System.Net.Http;
<span style=color:#66d9ef>using</span> System.Threading.Tasks;

<span style=color:#66d9ef>namespace</span> Exception.Examples
{
    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
    {
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> Task Main()
        {
             <span style=color:#66d9ef>var</span> tasks = <span style=color:#66d9ef>await</span> Task.WhenAll(Enumerable.Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5000</span>)
                 .Select(_ =&gt; <span style=color:#66d9ef>new</span> HttpClient().GetAsync(<span style=color:#e6db74>&#34;https://google.com&#34;</span>)));
             
             tasks
                 .Where(t =&gt; <span style=color:#66d9ef>true</span>)
                 .ToList()
                 .ForEach(r =&gt; Console.WriteLine(<span style=color:#e6db74>$&#34;Google answered {r.StatusCode}&#34;</span>));
        }
    }
}
</code></pre></div><blockquote><p><strong>Nota</strong>: <em>Top-level programs</em> ainda tem algumas coisas bem peculiares para tratar inferência dinâmica de tipos e de contextos assíncronos e paralelos no C# 9, então vamos no clássico <em>entrypoint program</em> mesmo.</p></blockquote><p>Um código bem simples, e que - se liga no <em>plot twist</em> - funciona perfeitamente bem! O motivo de tudo funcionar como deveria, é que temos implementado somente uma única responsabilidade dentro da função paralela e assíncrona, onde é iniciado 5000 <code>Task&lt;HttpResponseMessage></code> que será aguardada logo no seu <em>enclosure</em> que é justamente a própria <code>Task.WhenAll</code>, por ser uma expressão LINQ, o código pode ser um pouco difícil de ler, mas nada que alguns minutos de leitura não resolva.</p><p>O problema que estamos tentando criar, acontece quando além dessa única coisa que é feita (<code>return new HttpClient().GetAsync("https://google.com"))</code>, na expressão anônima da extensão <code>Select()</code> lá do LINQ), adicionamos alguma função que freia a execução dessa <em>thread</em>, por exemplo, escrever na tela informações da requisição conforme são executadas, vamos alterar um pouco o código e adicionar algumas funções que fação operações de IO:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#66d9ef>await</span> Task.WhenAll(Enumerable.Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5000</span>)
    .Select(<span style=color:#66d9ef>async</span> _ =&gt;
    {
        <span style=color:#66d9ef>try</span>
        {
            <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>new</span> HttpClient().GetAsync(<span style=color:#e6db74>&#34;https://google.com&#34;</span>);
            Console.Write(<span style=color:#e6db74>$&#34;Remote {response.RequestMessage?.RequestUri} answered {response.StatusCode}, &#34;</span>);

            <span style=color:#66d9ef>var</span> content = <span style=color:#66d9ef>await</span> response.Content.ReadAsByteArrayAsync();
            Console.WriteLine(<span style=color:#e6db74>$&#34;with a length of {content.Length} byte(s)&#34;</span>);
        
            <span style=color:#66d9ef>return</span> response;
        }
        <span style=color:#66d9ef>catch</span> (System.Exception e)
        {
            Console.WriteLine(e.InnerException != <span style=color:#66d9ef>null</span>
              ? <span style=color:#e6db74>$&#34;Error: {e.InnerException.Message}&#34;</span>
              : <span style=color:#e6db74>$&#34;Error: {e.Message}&#34;</span>);
        }
        
    }));
<span style=color:#75715e>// ...
</span></code></pre></div><p>Nesse cenário como temos a interação com operações que causam problemas na hora de serem executadas, e nem por realizarem operações de IO com <code>response.Content.ReadAsByteArrayAsync()</code> mas sim pela escrita na tela usando <code>System.Console</code>, que causa um <em>lock</em> e vira uma bagunça, quem estiver disponível, executa essa função.</p><p>Quando você executar esse código (além de receber um belíssimo banimento da Google por realizar milhares de requisições em tão pouco tempo), vai se deparar com algumas exceções de <code>Task</code> ao invés das instâncias de classes referentes a pilha de rede do .NET, no caso a famosa mensagem &ldquo;<em>The operation was canceled</em>&rdquo;.</p><p>E justamente quando receber essa resposta, é que os problemas do paralelismo começam a perturbar sua sanidade.</p><h1 id=resolvendo-com-uma-boa-sinalização>Resolvendo com uma boa sinalização<a hidden class=anchor aria-hidden=true href=#resolvendo-com-uma-boa-sinalização>#</a></h1><p>Existem diversas APIs que são fornecidas dentro do CLR para sanar os problemas de paralelismo que correspondem a estes erros, podemos realizar a implementação mais simples que conheço, que tem pouquíssimas alterações no código fonte original da aplicação, utilizando <code>SemaphoreSlim</code> para corrigir esse fiasco.</p><p>Podemos resumir esse elemento de <code>System.Threads</code> como sendo uma entidade responsável por limitar o número de <em>threads</em> que podem acessar uma <em>pool</em> de recursos, que é justamente o que causa &ldquo;<em>The operation was canceled</em>&rdquo; dentro de uma <code>Task</code>. Sua implementação é bem simples, e ele receber por padrão um único argumento correspondente a quantidade máxima de <em>threads</em> que podem ser alocadas para acessar estes recursos:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>var</span> semaphore = <span style=color:#66d9ef>new</span> SemaphoreSlim(Environment.ProcessorCount);
<span style=color:#66d9ef>await</span> Task.WhenAll(Enumerable.Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1000</span>)
    .Select(<span style=color:#66d9ef>async</span> _ =&gt;
    {
        <span style=color:#66d9ef>await</span> semaphore.WaitAsync();
        <span style=color:#66d9ef>try</span>
        {
            <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>new</span> HttpClient().GetAsync(<span style=color:#e6db74>&#34;https://zup.com.br&#34;</span>);
            Console.Write(<span style=color:#e6db74>$&#34;Remote {response.RequestMessage?.RequestUri} answered {response.StatusCode}, &#34;</span>);

            <span style=color:#66d9ef>var</span> content = <span style=color:#66d9ef>await</span> response.Content.ReadAsByteArrayAsync();
            Console.WriteLine(<span style=color:#e6db74>$&#34;with a length of {content.Length} byte(s)&#34;</span>);

            <span style=color:#66d9ef>return</span> response;
        }
        <span style=color:#66d9ef>catch</span> (System.Exception e)
        {
            Console.WriteLine(e.InnerException != <span style=color:#66d9ef>null</span>
                ? <span style=color:#e6db74>$&#34;Error: {e.InnerException.Message}&#34;</span>
                : <span style=color:#e6db74>$&#34;Error: {e.Message}&#34;</span>);

            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
        }
        <span style=color:#66d9ef>finally</span>
        {
            semaphore.Release();
        }
    }));
</code></pre></div><p>Agora além de podermos controlar o número de <em>threads</em> que serão utilizados para realizar as requisições, também não vamos ter problemas de concorrência ao tentar processar essa <em>pool</em> de tarefas alocadas no fluxo de execução da aplicação.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://exception.blog/tags/dotnet/>dotnet</a></li><li><a href=https://exception.blog/tags/parallel/>parallel</a></li><li><a href=https://exception.blog/tags/async/>async</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://exception.blog>Jojo's Exception</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://exception.blog/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});if(id==="top"){history.replaceState(null,null," ");}else{history.replaceState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>
[{"content":"Dando um push() no problema Um dos desafios que nem com as técnicas mais sombrias de debugging me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos estavam retornando uma exceção baseada no cancelamento das referências das instâncias dos vários CancellationToken utilizados para construir o cliente das requisições.\nFoi uma discussão bem legal com alguns monstros da CLR e até mesmo do Roslyn, que com uma paciência de Jó, conseguiram ir a fundo na explicação sobre o funcionamento da pilha de rede dentro do .NET, e também, sobre a abstração que estava consumindo. No geral, as diversas tasks que havia emitido, que foram passadas para serem aguardadas sua execução até o fim como parâmetro da função WhenAll lá do binário System.Runtime.dll.\n Para não descer muito o nível, e deixar tudo de maneira bem entendível, não vou abranger muito a explicação que absorvi, e focar na resolução desse problema relativamente simples.\n Nem sempre é tudo uma questão de alto nível Em contextos de paralelismo com tarefas que consomem muito tempo do processador, ainda que existem outras várias camadas para orquestrarem essas tarefas, desde de o próprio CPU até o sistema operacional e a própria stack de desenvolvimento, cabe a nós implementarmos controles eficazes na orquestração nas nossas próprias tarefas.\nEspecialmente nas linguagens de altíssimo nível, que entregam uma abstração muito abstrata - eu ri por dentro aqui - do que realmente é uma thread, devemos ter essa atenção dobrada para não cair em um contexto de cancelamento pois o tempo de resposta da aplicação para o ambiente onde foi delegada sua execução chegar ao limite.\nNesse cenário do HttpClientHandler e do HttpClient isso fica mais fácil de se perceber, mesmo que você implemente um timeout na casa dos TimeSpam.FromDays(666), se o tempo de execução de qualquer uma das funções assíncronas do HttpClient, como a mais utilizada HttpClient.SendAsync(HttpRequestMessage), podem retornar um timeout, mas não da resposta HTTP do servidor, e sim da sua Task que está no limbo do atual contexto de processamento.\n Vai por mim, evite utilizar funções que podem receber uma sobrecarga de uma instância de CancellationToken, se ela pode trabalhar com os status provenientes dessa estrutura, algum motivo tem.\n Para simplificar o entendimento de todo esse cenário intangível, vamos trazer ao código uma péssima prática de programação (que quase me fez desistir do desenvolvimento do HttpDoom) relacionada ao paralelismo e assincronicidade de código:\nusing System; using System.Linq; using System.Net.Http; using System.Threading.Tasks; namespace Exception.Examples { internal static class Program { public static async Task Main() { var tasks = await Task.WhenAll(Enumerable.Range(1, 5000) .Select(_ =\u0026gt; new HttpClient().GetAsync(\u0026#34;https://google.com\u0026#34;))); tasks .Where(t =\u0026gt; true) .ToList() .ForEach(r =\u0026gt; Console.WriteLine($\u0026#34;Google answered {r.StatusCode}\u0026#34;)); } } }  Nota: Top-level programs ainda tem algumas coisas bem peculiares para tratar inferência dinâmica de tipos e de contextos assíncronos e paralelos no C# 9, então vamos no clássico entrypoint program mesmo.\n Um código bem simples, e que - se liga no plot twist - funciona perfeitamente bem! O motivo de tudo funcionar como deveria, é que temos implementado somente uma única responsabilidade dentro da função paralela e assíncrona, onde é iniciado 5000 Task\u0026lt;HttpResponseMessage\u0026gt; que será aguardada logo no seu enclosure que é justamente a própria Task.WhenAll, por ser uma expressão LINQ, o código pode ser um pouco difícil de ler, mas nada que alguns minutos de leitura não resolva.\nO problema que estamos tentando criar, acontece quando além dessa única coisa que é feita (return new HttpClient().GetAsync(\u0026quot;https://google.com\u0026quot;)), na expressão anônima da extensão Select() lá do LINQ), adicionamos alguma função que freia a execução dessa thread, por exemplo, escrever na tela informações da requisição conforme são executadas, vamos alterar um pouco o código e adicionar algumas funções que fação operações de IO:\n// ... await Task.WhenAll(Enumerable.Range(1, 5000) .Select(async _ =\u0026gt; { try { var response = await new HttpClient().GetAsync(\u0026#34;https://google.com\u0026#34;); Console.Write($\u0026#34;Remote {response.RequestMessage?.RequestUri} answered {response.StatusCode}, \u0026#34;); var content = await response.Content.ReadAsByteArrayAsync(); Console.WriteLine($\u0026#34;with a length of {content.Length} byte(s)\u0026#34;); return response; } catch (System.Exception e) { Console.WriteLine(e.InnerException != null ? $\u0026#34;Error: {e.InnerException.Message}\u0026#34; : $\u0026#34;Error: {e.Message}\u0026#34;); } })); // ... Nesse cenário como temos a interação com operações que causam problemas na hora de serem executadas, e nem por realizarem operações de IO com response.Content.ReadAsByteArrayAsync() mas sim pela escrita na tela usando System.Console, que causa um lock e vira uma bagunça, quem estiver disponível, executa essa função.\nQuando você executar esse código (além de receber um belíssimo banimento da Google por realizar milhares de requisições em tão pouco tempo), vai se deparar com algumas exceções de Task ao invés das instâncias de classes referentes a pilha de rede do .NET, no caso a famosa mensagem \u0026ldquo;The operation was canceled\u0026rdquo;.\nE justamente quando receber essa resposta, é que os problemas do paralelismo começam a perturbar sua sanidade.\nResolvendo com uma boa sinalização Existem diversas APIs que são fornecidas dentro do CLR para sanar os problemas de paralelismo que correspondem a estes erros, podemos realizar a implementação mais simples que conheço, que tem pouquíssimas alterações no código fonte original da aplicação, utilizando SemaphoreSlim para corrigir esse fiasco.\nPodemos resumir esse elemento de System.Threads como sendo uma entidade responsável por limitar o número de threads que podem acessar uma pool de recursos, que é justamente o que causa \u0026ldquo;The operation was canceled\u0026rdquo; dentro de uma Task. Sua implementação é bem simples, e ele receber por padrão um único argumento correspondente a quantidade máxima de threads que podem ser alocadas para acessar estes recursos:\nvar semaphore = new SemaphoreSlim(Environment.ProcessorCount); await Task.WhenAll(Enumerable.Range(1, 1000) .Select(async _ =\u0026gt; { await semaphore.WaitAsync(); try { var response = await new HttpClient().GetAsync(\u0026#34;https://zup.com.br\u0026#34;); Console.Write($\u0026#34;Remote {response.RequestMessage?.RequestUri} answered {response.StatusCode}, \u0026#34;); var content = await response.Content.ReadAsByteArrayAsync(); Console.WriteLine($\u0026#34;with a length of {content.Length} byte(s)\u0026#34;); return response; } catch (System.Exception e) { Console.WriteLine(e.InnerException != null ? $\u0026#34;Error: {e.InnerException.Message}\u0026#34; : $\u0026#34;Error: {e.Message}\u0026#34;); return null; } finally { semaphore.Release(); } })); Agora além de podermos controlar o número de threads que serão utilizados para realizar as requisições, também não vamos ter problemas de concorrência ao tentar processar essa pool de tarefas alocadas no fluxo de execução da aplicação.\n","permalink":"https://exception.blog/posts/problemas-com-httpclient-resolvidos/","summary":"Dando um push() no problema Um dos desafios que nem com as técnicas mais sombrias de debugging me ajudaram a entender o que meu contexto de requisições HTTP assíncronos e paralelos estavam retornando uma exceção baseada no cancelamento das referências das instâncias dos vários CancellationToken utilizados para construir o cliente das requisições.\nFoi uma discussão bem legal com alguns monstros da CLR e até mesmo do Roslyn, que com uma paciência de Jó, conseguiram ir a fundo na explicação sobre o funcionamento da pilha de rede dentro do .","title":"Solucionando problemas de sincronismo de requisições em paralelo com SemaphoreSlim"},{"content":"Olá, como deve ter percebido, sou o Jojo, escrevo neste blog coisas que gosto, focados em segurança da informação, linguagens de programação exotéricas e um pouco de compiladores/interpretadores de linguagens ainda mais estranhas. Todo o conteúdo (e o próprio blog) está disponível nesse repositório esperando seu forks e também pull-requests caso quiser publicar algo, bem como corrigir uma cagada ou outra que escrevo aqui.\nPara entrar em contato comigo, é só pegar minha chave no Keybase, e enviar uma mensagem para jonas dot uliana at passwd dotcom dot br (ou preferencialmente por lá mesmo).\n The content is aimed at Brazilian Portuguese, but some posts are available in English as well.\n ","permalink":"https://exception.blog/about/","summary":"Olá, como deve ter percebido, sou o Jojo, escrevo neste blog coisas que gosto, focados em segurança da informação, linguagens de programação exotéricas e um pouco de compiladores/interpretadores de linguagens ainda mais estranhas. Todo o conteúdo (e o próprio blog) está disponível nesse repositório esperando seu forks e também pull-requests caso quiser publicar algo, bem como corrigir uma cagada ou outra que escrevo aqui.\nPara entrar em contato comigo, é só pegar minha chave no Keybase, e enviar uma mensagem para jonas dot uliana at passwd dotcom dot br (ou preferencialmente por lá mesmo).","title":"About"}]